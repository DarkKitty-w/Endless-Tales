
'use server';
/**
 * @fileOverview An AI agent that narrates the story of a text adventure game based on player actions and game state.
 *
 * - narrateAdventure - A function that narrates the adventure story.
 * - NarrateAdventureInput - The input type for the narrateAdventure function.
 * - NarrateAdventureOutput - The return type for the narrateAdventure function.
 */
import {ai} from '@/ai/ai-instance';
import {z} from 'genkit';
import type {
  CharacterStats,
  Reputation,
  NpcRelationships,
  ReputationChange,
  NpcRelationshipChange,
} from '@/types/character-types';
import type {DifficultyLevel} from '@/types/game-types';
import {SkillSchema} from '@/ai/schemas/skill-schema';
import type { GenreTheme, MagicSystem, TechLevel, DominantTone, CombatFrequency, PuzzleFrequency, SocialFocus } from '@/types/adventure-types';


// Schemas
const BranchingChoiceSchema = z.object({
  text: z.string().describe('The player-facing text for this choice.'),
  consequenceHint: z
    .string()
    .optional()
    .describe(
      'A brief hint about the potential consequences of this choice.'
    ),
});

const NarrateAdventureInputSchema = z.object({
  character: z.object({
    name: z.string().describe('The character\'s name.'),
    class: z.string().describe('The character\'s class (e.g., Warrior, Mage). For Immersed mode, this might be an archetype or role from the universe like "Jedi Knight" or "Immersed Protagonist".'),
    description: z.string().describe('A description of the character.'),
    traits: z.array(z.string()).describe('A list of character traits.'),
    knowledge: z.array(z.string()).describe('A list of areas of knowledge.'),
    background: z.string().describe('The character\'s background.'),
    stats: z.object({
      strength: z.number(),
      stamina: z.number(),
      agility: z.number(),
      intellect: z.number(),
      wisdom: z.number(),
      charisma: z.number(),
    }).describe('The character\'s stats.'),
    currentStamina: z.number().describe('The character\'s current stamina.'),
    maxStamina: z.number().describe('The character\'s maximum stamina.'),
    currentMana: z.number().describe('The character\'s current mana.'),
    maxMana: z.number().describe('The character\'s maximum mana, if applicable.'),
    level: z.number().describe('The character\'s current level.'),
    xp: z.number().describe('The character\'s current experience points.'),
    xpToNextLevel: z.number().describe('The experience points needed to reach the next level.'),
    reputation: z.record(z.number()).describe('The character\'s reputation with different factions.'),
    npcRelationships: z.record(z.number()).describe('The character\'s relationships with different NPCs.'),
    skillTreeSummary: z
      .object({
        className: z.string(),
        stageCount: z.number(),
        availableSkillsAtCurrentStage: z.array(z.string()),
      })
      .nullable()
      .describe('A summary of the character\'s skill tree and available skills. Not applicable for Immersed mode with existing characters or if no skill system is used.'),
    skillTreeStage: z.number().describe('The character\'s current skill tree stage. Not applicable for Immersed mode with existing characters.'),
    learnedSkills: z.array(z.string()).describe('List of learned skill names. May be less relevant or narrative-driven for Immersed mode.'),
    aiGeneratedDescription: z.string().optional().describe("A description of the character that was generated by AI."),
  }),
  playerChoice: z.string().describe('The action the player chose to perform.'),
  gameState: z.string().describe('The current game state.'),
  previousNarration: z.string().optional().describe('The previous narration in the story.'),
  adventureSettings: z.object({
    difficulty: z.string().describe('The difficulty level of the adventure.'),
    permanentDeath: z.boolean().describe('Whether permanent death is enabled.'),
    adventureType: z.string().describe('The type of adventure (Randomized, Custom, Immersed).'),
    // Custom Adventure Fields
    worldType: z.string().optional().describe('The type of world for custom adventures.'),
    mainQuestline: z.string().optional().describe('The main questline for custom adventures.'),
    genreTheme: z.string().optional().describe('The genre/theme for custom adventures.'),
    magicSystem: z.string().optional().describe('The magic system for custom adventures.'),
    techLevel: z.string().optional().describe('The technological level for custom adventures.'),
    dominantTone: z.string().optional().describe('The dominant tone for custom adventures.'),
    startingSituation: z.string().optional().describe('The starting situation for custom adventures.'),
    combatFrequency: z.string().optional().describe('The combat frequency for custom adventures.'),
    puzzleFrequency: z.string().optional().describe('The puzzle frequency for custom adventures.'),
    socialFocus: z.string().optional().describe('The social interaction focus for custom adventures.'),
    // Immersed Adventure Fields
    universeName: z.string().optional().describe('The universe the immersed adventure takes place in'),
    playerCharacterConcept: z.string().optional().describe('For Immersed mode: The existing character name or original character concept.'),
    characterOriginType: z.enum(['existing', 'original']).optional().describe('For Immersed mode: Whether the character is existing or original.'),
  }),
  turnCount: z.number().describe('The current turn number.'),
});

const NarrateAdventureOutputSchema = z.object({
  narration: z.string().describe('The next segment of the story.'),
  updatedGameState: z.string().describe('The updated game state.'),
  updatedStats: z.object({
    strength: z.number().optional(),
    stamina: z.number().optional(),
    agility: z.number().optional(),
    intellect: z.number().optional(),
    wisdom: z.number().optional(),
    charisma: z.number().optional(),
  }).optional().describe("Optional: Updated stats if they changed. Only include changed stats."),
  updatedTraits: z.array(z.string()).optional().describe("Optional: Complete new list of traits if any were gained or lost."),
  updatedKnowledge: z.array(z.string()).optional().describe("Optional: Complete new list of knowledge areas if any were gained or lost."),
  progressedToStage: z.number().optional().describe("Optional: The new skill stage (0-4) if the character progressed (not applicable for Immersed mode with existing characters)."),
  staminaChange: z.number().optional().describe("Optional: Change in current stamina (negative for cost, positive for gain)."),
  manaChange: z.number().optional().describe("Optional: Change in current mana (negative for cost, positive for gain)."),
  xpGained: z.number().optional().describe("Optional: Amount of XP gained from the action/event (may be less relevant or narrative-driven for Immersed mode)."),
  reputationChange: z.object({ faction: z.string(), change: z.number() }).optional().describe("Optional: Change in reputation with a faction."),
  npcRelationshipChange: z.object({ npcName: z.string(), change: z.number() }).optional().describe("Optional: Change in relationship with an NPC."),
  suggestedClassChange: z.string().optional().describe("Optional: Suggest a different class name **only if the AI detects the player's actions consistently align with a different class (not applicable for Immersed mode).**"),
  gainedSkill: SkillSchema.optional().describe("Optional: Details of a new skill **only if the character learned a new skill (narrative-driven for Immersed mode).**"),
  branchingChoices: z.array(BranchingChoiceSchema).length(4).optional().describe("Optional: Always 4 significant choices presented to the player, **only if relevant narrative branches occurred.**"),
  dynamicEventTriggered: z.string().optional().describe("Optional: A brief description **only if a random or time-based dynamic world event occurred.**"),
});


export type NarrateAdventureInput = z.infer<typeof NarrateAdventureInputSchema>;
export type NarrateAdventureOutput = z.infer<typeof NarrateAdventureOutputSchema>;

export async function narrateAdventure(
  input: NarrateAdventureInput
): Promise<NarrateAdventureOutput> {
  if (input.character.class === 'admin000') {
    console.log("Developer Mode detected. Bypassing AI narration.");
    return processDevCommand(input);
  }
  return narrateAdventureFlow(input);
}

async function processDevCommand(input: NarrateAdventureInput): Promise<NarrateAdventureOutput> {
    let devNarration = `(Developer Mode) Player chose: "${input.playerChoice}".`;
    const command = input.playerChoice.trim().toLowerCase();
    const parts = command.split(' ');
    const baseCommand = parts[0];
    const value = parts.length > 1 ? parts.slice(1).join(' ') : undefined;

    let updatedStats: Partial<CharacterStats> | undefined;
    let xpGained: number | undefined;
    let progressedToStage: number | undefined;

    if (baseCommand === '/xp' && value) {
        const amount = parseInt(value, 10);
        if (!isNaN(amount)) {
            xpGained = amount;
            devNarration += ` Granted ${amount} XP.`;
        } else {
            devNarration += " - Invalid XP amount.";
        }
    } else if (baseCommand === '/stage' && value) {
        const stageNum = parseInt(value, 10);
        if (!isNaN(stageNum) && stageNum >= 0 && stageNum <= 4) {
            progressedToStage = stageNum;
            devNarration += ` Set skill stage to ${stageNum}.`;
        } else {
            devNarration += " - Invalid stage number (0-4).";
        }
    } else if (baseCommand === '/additem' && value) {
        devNarration += ` Attempted to add item: ${value}. (Dispatch ADD_ITEM in reducer)`;
    } else if (baseCommand === '/removeitem' && value) {
        devNarration += ` Attempted to remove item: ${value}. (Dispatch REMOVE_ITEM in reducer)`;
    } else {
        devNarration += " Action processed in developer mode. Restrictions bypassed.";
    }

    return {
        narration: devNarration,
        updatedGameState: `${input.gameState} (Dev Action: ${input.playerChoice}, Turn: ${input.turnCount + 1})`,
        xpGained,
        progressedToStage,
        updatedStats,
    };
}

const narrateAdventurePrompt = ai.definePrompt({
  name: 'narrateAdventurePrompt',
  input: { schema: NarrateAdventureInputSchema }, // Schema remains the same, transformation happens in the flow
  output: { schema: NarrateAdventureOutputSchema },
  prompt: `You are a creative Game Master AI for the text adventure "Endless Tales". Your task is to narrate the next segment of the story.

**Character Details:**
*   Name: {{{character.name}}}
*   Class/Role: {{{character.class}}} {{#if character.skillTreeSummary}}(Skill Stage: {{{character.skillTreeStage}}}/4 - {{character.skillTreeSummary.className}}){{/if}}
*   Description: {{#if character.aiGeneratedDescription}}{{character.aiGeneratedDescription}}{{else}}{{character.description}}{{/if}}
*   Traits: {{#if character.traits}}{{#each character.traits}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}}
*   Knowledge: {{#if character.knowledge}}{{#each character.knowledge}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}}
*   Background: {{{character.background}}}
*   Stats: STR {{{character.stats.strength}}}, STA {{{character.stats.stamina}}}, AGI {{{character.stats.agility}}}, INT {{{character.stats.intellect}}}, WIS {{{character.stats.wisdom}}}, CHA {{{character.stats.charisma}}}
*   Resources: Stamina {{character.currentStamina}}/{{character.maxStamina}}, Mana {{character.currentMana}}/{{character.maxMana}}
*   Level: {{character.level}} (XP: {{character.xp}}/{{character.xpToNextLevel}})
*   Learned Skills: {{#if character.learnedSkills}}{{#each character.learnedSkills}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}}
*   Reputation: {{#if character.reputationString}}{{character.reputationString}}{{else}}None{{/if}}
*   NPC Relationships: {{#if character.npcRelationshipsString}}{{character.npcRelationshipsString}}{{else}}None{{/if}}

**Game Settings & Context:**
*   Turn: {{{turnCount}}}
*   Difficulty: {{{adventureSettings.difficulty}}}
*   Permadeath: {{{adventureSettings.permanentDeath}}}
*   Adventure Type: {{{adventureSettings.adventureType}}}
{{#if (eq adventureSettings.adventureType "Custom")}}
*   World: {{{adventureSettings.worldType}}}
*   Main Quest: {{{adventureSettings.mainQuestline}}}
*   Genre/Theme: {{{adventureSettings.genreTheme}}}
*   Magic System: {{{adventureSettings.magicSystem}}}
*   Tech Level: {{{adventureSettings.techLevel}}}
*   Dominant Tone: {{{adventureSettings.dominantTone}}}
*   Starting Situation: {{{adventureSettings.startingSituation}}}
*   Combat Frequency: {{{adventureSettings.combatFrequency}}}
*   Puzzle Frequency: {{{adventureSettings.puzzleFrequency}}}
*   Social Focus: {{{adventureSettings.socialFocus}}}
{{else if (eq adventureSettings.adventureType "Immersed")}}
*   Universe: {{{adventureSettings.universeName}}}
*   Character Role/Concept: {{{adventureSettings.playerCharacterConcept}}} (Origin: {{{adventureSettings.characterOriginType}}})
*   **INSTRUCTION (Immersed):** The narrative MUST strongly adhere to the lore, characters, and tone of the specified 'Universe'. 
    *   If character origin is 'existing' AND this is Turn 1: **Attempt to start the narration at a recognizable and pivotal early point in this character's known story or a logical starting point for them within their established narrative.**
    *   Avoid class-based skill trees, XP, and standard leveling for Immersed mode; character development, new abilities, or status changes should be purely narrative-driven and logical within the universe.
{{else if (eq adventureSettings.adventureType "Randomized")}}
*   **INSTRUCTION (Randomized):** Focus the narration on establishing a unique setting, initial challenge, or short-term goal derived directly from the character's class, background, traits, or knowledge. Use these details to make the randomized world feel tailored to the player character, especially in early turns.
{{/if}}
*   Previous Narration (if any): {{{previousNarration}}}
*   Current Game State: {{{gameState}}}

**Player's Chosen Action:**
{{{playerChoice}}} (This may include dice roll results like "(Difficulty: Normal, Dice Roll Result: 15/20)")

**Your Task & Output Requirements:**

1.  **Narrative Continuation:** Craft an engaging narrative that seamlessly continues the story, logically following the 'playerChoice' within the 'gameState'. Consider all character details, game settings, and the specific instructions for the adventure type.
2.  **Logical Progression, Resource Costs & Restrictions:**
    *   **Evaluate Feasibility:** Assess if the action is logically possible. *Actions tied to higher skill stages (if applicable, i.e., not Immersed mode) should only be possible if the character has reached that stage.* Harder difficulties might make certain actions less feasible initially.
    *   **Check Learned Skills & Resources:** Verify if a used skill is learned and if enough resources (stamina/mana) are available. Narrate failure reasons (not learned, insufficient resources). Calculate costs and output \`staminaChange\`, \`manaChange\` **only if they changed**.
    *   **Block Impossible Actions:** Prevent universe-breaking actions (e.g., "destroy the universe") unless EXTREME justification exists in gameState AND skill stage is high (if applicable). Simple reality-bending ("become king instantly") is also typically Impossible without justification.
    *   **Narrate Failure Reason:** If blocked/failed, explain why (lack of skill, resources, item, stage, reputation, **NPC relationships**, difficulty, etc.).
    *   **Skill-based Progression (Not for Immersed):** Very powerful actions require high milestones AND skill stages.
3.  **Incorporate Dice Rolls:** Interpret dice roll results (e.g., "(Difficulty: Hard, Dice Roll Result: 75/100)") contextually. High rolls succeed, low rolls fail, adjusted by **game difficulty**. Narrate the degree of success/failure. Success might grant more XP or better reputation/relationship changes. Failure might have negative consequences, potentially more severe on higher difficulties.
4.  **Consequences, Resources, XP, Reputation, Relationships & Character Progression:**
    *   **Resource Changes:** If current stamina or mana changed, include \`staminaChange\` or \`manaChange\`. **Do not include if unchanged.**
    *   **XP Awards (Not for Immersed):** If the action was significant, award XP via \`xpGained\` (adjust based on **difficulty**). **Only include if XP was gained.**
    *   **Reputation Changes:** If the action affects a faction's view, include \`reputationChange\`. **Only include if reputation changed.**
    *   **NPC Relationship Changes:** If the action affects an NPC's view, include \`npcRelationshipChange\`. **Only include if relationship changed.**
    *   **Character Progression (Optional, narrative for Immersed):** If events lead to development:
        *   Include \`updatedStats\`, \`updatedTraits\`, \`updatedKnowledge\`. **Only include if they changed.**
        *   **Skill Stage Progression (Not for Immersed):** Include \`progressedToStage\` **only if milestones warrant advancement.**
        *   **Class Change Suggestion (Not for Immersed):** Include \`suggestedClassChange\` **only if actions strongly align elsewhere.**
        *   **Gaining Skills (Narrative for Immersed):** Include \`gainedSkill\` **only if appropriate.**
5.  **Update Game State String:** Modify the 'gameState' string to reflect **ALL** changes (location, inventory, NPC moods, time, quest progress, milestones, status like 'Injured'). **It MUST include the current Turn count, which is always {{{turnCount}}} + 1.**
6.  **Dynamic Events & Branching:** Occasionally, introduce dynamic world events (via \`dynamicEventTriggered\`) or present the player with **EXACTLY 4** meaningful branching choices (via \`branchingChoices\`) if the narrative allows. These choices should have hints.
7.  **Tone:** Maintain a consistent tone suitable for the adventure type and difficulty.

**Output Format:** Respond ONLY with the JSON object matching the NarrateAdventureOutput schema.
*   \`narration\` and \`updatedGameState\` are **REQUIRED**.
*   All other fields are **OPTIONAL** and should **ONLY** be included if their corresponding event actually occurred.
*   If including \`branchingChoices\`, ensure the array contains **exactly 4** choices.
*   Ensure the \`updatedGameState\` string contains the correct turn count.
`,
});

const narrateAdventureFlow = ai.defineFlow(
  {
    name: 'narrateAdventureFlow',
    inputSchema: NarrateAdventureInputSchema,
    outputSchema: NarrateAdventureOutputSchema,
  },
  async input => {
    // Pre-process data for the prompt
    const reputationString = JSON.stringify(input.character.reputation);
    const npcRelationshipsString = JSON.stringify(input.character.npcRelationships);

    const promptInput = {
      ...input,
      character: {
        ...input.character,
        reputationString: Object.keys(input.character.reputation).length > 0 ? reputationString : "", // Pass empty string if object is empty
        npcRelationshipsString: Object.keys(input.character.npcRelationships).length > 0 ? npcRelationshipsString : "", // Pass empty string if object is empty
      },
    };

    console.log("Sending to narrateAdventurePrompt:", JSON.stringify(promptInput, null, 2));
    const {output} = await narrateAdventurePrompt(promptInput);
    console.log("Received from narrateAdventurePrompt:", JSON.stringify(output, null, 2));
     if (!output) {
        return {
            narration: "The AI seems to be pondering... or perhaps napping. (No output received)",
            updatedGameState: input.gameState,
        };
    }
    return output;
  }
);

