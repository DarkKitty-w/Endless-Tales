
'use server';
/**
 * @fileOverview An AI agent that narrates the story of a text adventure game based on player actions and game state.
 *
 * - narrateAdventure - A function that narrates the adventure story.
 * - NarrateAdventureInput - The input type for the narrateAdventure function.
 * - NarrateAdventureOutput - The return type for the narrateAdventure function.
 */
import {ai}from '@/ai/ai-instance';
import {z}from 'genkit';
import type {
  CharacterStats,
  Reputation,
  NpcRelationships,
} from '@/types/character-types';
import type {DifficultyLevel} from '@/types/game-types';
import {SkillSchema} from '@/ai/schemas/skill-schema';
import type { GenreTheme, MagicSystem, TechLevel, DominantTone, CombatFrequency, PuzzleFrequency, SocialFocus } from '@/types/adventure-types';

// Schemas
const BranchingChoiceSchema = z.object({
  text: z.string().describe('The player-facing text for this choice.'),
  consequenceHint: z
    .string()
    .optional()
    .describe(
      'A brief hint about the potential consequences of this choice.'
    ),
});

const CharacterInputForPromptSchema = z.object({
    name: z.string().describe("The character's name."),
    class: z.string().describe("The character's class (e.g., Warrior, Mage). For Immersed mode, this might be an archetype or role from the universe like \"Jedi Knight\" or \"Immersed Protagonist\"."),
    description: z.string().describe('A description of the character.'),
    traits: z.array(z.string()).describe('A list of character traits.'),
    knowledge: z.array(z.string()).describe('A list of areas of knowledge.'),
    background: z.string().describe("The character's background."),
    stats: z.object({
      strength: z.number(),
      stamina: z.number(),
      wisdom: z.number(),
    }).describe("The character's core stats (Strength, Stamina, Wisdom)."),
    currentHealth: z.number().describe("The character's current health points (HP)."),
    maxHealth: z.number().describe("The character's maximum health points."),
    currentStamina: z.number().describe("The character's current action stamina (for physical actions)."),
    maxStamina: z.number().describe("The character's maximum action stamina."),
    currentMana: z.number().describe("The character's current mana (for magical/special abilities)."),
    maxMana: z.number().describe("The character's maximum mana."),
    level: z.number().describe("The character's current level."),
    xp: z.number().describe("The character's current experience points."),
    xpToNextLevel: z.number().describe("The experience points needed to reach the next level."),
    reputationString: z.string().optional().describe("Stringified JSON of reputation with factions."),
    npcRelationshipsString: z.string().optional().describe("Stringified JSON of relationships with NPCs."),
    skillTreeSummary: z
      .object({
        className: z.string(),
        stageCount: z.number(),
        availableSkillsAtCurrentStage: z.array(z.string()),
      })
      .nullable()
      .describe("A summary of the character's skill tree and available skills. Not applicable for Immersed mode with existing characters or if no skill system is used."),
    skillTreeStage: z.number().describe("The character's current skill tree stage. Not applicable for Immersed mode with existing characters."),
    learnedSkills: z.array(z.string()).describe("List of learned skill names. May be less relevant or narrative-driven for Immersed mode."),
    aiGeneratedDescription: z.string().optional().describe("A description of the character that was generated by AI."),
});


const NarrateAdventureInputSchema = z.object({
  character: CharacterInputForPromptSchema,
  playerChoice: z.string().describe('The action the player chose to perform.'),
  gameState: z.string().describe('The current game state.'),
  previousNarration: z.string().optional().describe('The previous narration in the story.'),
  adventureSettings: z.object({
    difficulty: z.string().describe('The difficulty level of the adventure.'),
    permanentDeath: z.boolean().describe('Whether permanent death is enabled.'),
    adventureType: z.string().describe('The type of adventure (Randomized, Custom, Immersed).'),
    worldType: z.string().optional().describe('The type of world for custom adventures.'),
    mainQuestline: z.string().optional().describe('The main questline for custom adventures.'),
    genreTheme: z.string().optional().describe('The genre/theme for custom adventures.'),
    magicSystem: z.string().optional().describe('The magic system for custom adventures.'),
    techLevel: z.string().optional().describe('The technological level for custom adventures.'),
    dominantTone: z.string().optional().describe('The dominant tone for custom adventures.'),
    startingSituation: z.string().optional().describe('The starting situation for custom adventures.'),
    combatFrequency: z.string().optional().describe('The combat frequency for custom adventures.'),
    puzzleFrequency: z.string().optional().describe('The puzzle frequency for custom adventures.'),
    socialFocus: z.string().optional().describe('The social interaction focus for custom adventures.'),
    universeName: z.string().optional().describe('The universe the immersed adventure takes place in'),
    playerCharacterConcept: z.string().optional().describe('For Immersed mode: The existing character name or original character concept.'),
    characterOriginType: z.enum(['existing', 'original']).optional().describe('For Immersed mode: Whether the character is existing or original.'),
  }),
  turnCount: z.number().describe('The current turn number.'),
  isCustomAdventure: z.boolean().optional(),
  isRandomizedAdventure: z.boolean().optional(),
  isImmersedAdventure: z.boolean().optional(),
});


const NarrateAdventureOutputSchema = z.object({
  narration: z.string().describe('The next segment of the story.'),
  updatedGameState: z.string().describe('The updated game state.'),
  updatedStats: z.object({
    strength: z.number().optional(),
    stamina: z.number().optional(),
    wisdom: z.number().optional(),
  }).optional().describe("Optional: Updated stats if they changed. Only include changed stats."),
  updatedTraits: z.array(z.string()).optional().describe("Optional: Complete new list of traits if any were gained or lost."),
  updatedKnowledge: z.array(z.string()).optional().describe("Optional: Complete new list of knowledge areas if any were gained or lost."),
  progressedToStage: z.number().optional().describe("Optional: The new skill stage (0-4) if the character progressed (not applicable for Immersed mode with existing characters)."),
  healthChange: z.number().optional().describe("Optional: Change in current health (negative for damage, positive for healing)."),
  staminaChange: z.number().optional().describe("Optional: Change in current action stamina (negative for cost, positive for gain)."),
  manaChange: z.number().optional().describe("Optional: Change in current mana (negative for cost, positive for gain)."),
  xpGained: z.number().optional().describe("Optional: Amount of XP gained from the action/event (may be less relevant or narrative-driven for Immersed mode)."),
  reputationChange: z.object({ faction: z.string(), change: z.number() }).optional().describe("Optional: Change in reputation with a faction."),
  npcRelationshipChange: z.object({ npcName: z.string(), change: z.number() }).optional().describe("Optional: Change in relationship with an NPC."),
  suggestedClassChange: z.string().optional().describe("Optional: Suggest a different class name **only if the AI detects the player's actions consistently align with a different class (not applicable for Immersed mode).**"),
  gainedSkill: SkillSchema.optional().describe("Optional: Details of a new skill **only if the character learned a new skill (narrative-driven for Immersed mode).**"),
  branchingChoices: z.array(BranchingChoiceSchema).length(4).describe("ALWAYS provide 4 significant choices presented to the player."),
  dynamicEventTriggered: z.string().optional().describe("Optional: A brief description **only if a random or time-based dynamic world event occurred.**"),
  isCharacterDefeated: z.boolean().optional().describe("True if the character's health dropped to 0 or below or a death condition was met through narration."),
});


export type NarrateAdventureInput = z.infer<typeof NarrateAdventureInputSchema>;
export type NarrateAdventureOutput = z.infer<typeof NarrateAdventureOutputSchema>;

export async function narrateAdventure(
  input: NarrateAdventureInput
): Promise<NarrateAdventureOutput> {
  console.log(`NarrateAdventure AI Flow: Called for Turn ${input.turnCount}, Action: "${input.playerChoice.substring(0,50)}..."`);
  if (input.character.class === 'admin000') {
    console.log("NarrateAdventure AI Flow: Developer Mode detected. Bypassing AI narration.");
    return processDevCommand(input);
  }
  return narrateAdventureFlow(input);
}

// Helper function for developer commands
function processDevCommand(input: NarrateAdventureInput): NarrateAdventureOutput {
    let devNarration = `(Developer Mode) Player chose: "${input.playerChoice}".`;
    const command = input.playerChoice.trim().toLowerCase();
    const parts = command.split(' ');
    const baseCommand = parts[0];
    const value = parts.length > 1 ? parts.slice(1).join(' ') : undefined;

    let xpGained: number | undefined;
    let progressedToStage: number | undefined;
    let healthChange: number | undefined;
    let staminaChange: number | undefined;
    let manaChange: number | undefined;
    let updatedTraits: string[] | undefined;
    let updatedKnowledge: string[] | undefined;
    let gainedSkill: z.infer<typeof SkillSchema> | undefined;

    if (baseCommand === '/xp' && value) {
        const amount = parseInt(value, 10);
        if (!isNaN(amount)) { xpGained = amount; devNarration += ` Granted ${amount} XP.`; }
        else { devNarration += " - Invalid XP amount."; }
    } else if (baseCommand === '/stage' && value) {
        const stageNum = parseInt(value, 10);
        if (!isNaN(stageNum) && stageNum >= 0 && stageNum <= 4) { progressedToStage = stageNum; devNarration += ` Set skill stage to ${stageNum}.`; }
        else { devNarration += " - Invalid stage number (0-4)."; }
    } else if (baseCommand === '/health' && value && input.character) {
        const amount = parseInt(value, 10);
        if (!isNaN(amount)) {
            const newHealth = Math.max(0, Math.min(input.character.maxHealth, input.character.currentHealth + amount));
            healthChange = newHealth - input.character.currentHealth;
            devNarration += ` Adjusted health by ${healthChange}. New health: ${newHealth}.`;
        } else {
            devNarration += " - Invalid health amount.";
        }
    } else if (baseCommand === '/stamina' && value && input.character) {
        const amount = parseInt(value, 10);
        if (!isNaN(amount)) {
            const newStamina = Math.max(0, Math.min(input.character.maxStamina, input.character.currentStamina + amount));
            staminaChange = newStamina - input.character.currentStamina;
            devNarration += ` Adjusted action stamina by ${staminaChange}. New action stamina: ${newStamina}.`;
        } else {
            devNarration += " - Invalid action stamina amount.";
        }
    } else if (baseCommand === '/mana' && value && input.character) {
        const amount = parseInt(value, 10);
        if (!isNaN(amount)) {
            const newMana = Math.max(0, Math.min(input.character.maxMana, input.character.currentMana + amount));
            manaChange = newMana - input.character.currentMana;
            devNarration += ` Adjusted mana by ${manaChange}. New mana: ${newMana}.`;
        } else {
            devNarration += " - Invalid mana amount.";
        }
    } else if (baseCommand === '/addtrait' && value && input.character) {
        updatedTraits = [...(input.character.traits || []), value];
        devNarration += ` Added trait: ${value}.`;
    } else if (baseCommand === '/addknowledge' && value && input.character) {
        updatedKnowledge = [...(input.character.knowledge || []), value];
        devNarration += ` Added knowledge: ${value}.`;
    } else if (baseCommand === '/addskill' && value && input.character) {
        gainedSkill = { name: value, description: "Developer added skill", type: 'Learned' };
        devNarration += ` Added skill: ${value}.`;
    } else {
        devNarration += " Action processed. Dev restrictions bypassed.";
    }

    return {
        narration: devNarration,
        updatedGameState: `${input.gameState} (Dev Action: ${input.playerChoice}, Turn: ${input.turnCount + 1})`,
        xpGained,
        progressedToStage,
        healthChange,
        staminaChange,
        manaChange,
        updatedTraits,
        updatedKnowledge,
        gainedSkill,
        branchingChoices: [ // Provide generic choices for dev mode
            { text: "Continue as planned." },
            { text: "Inspect the environment." },
            { text: "Check character status." },
            { text: "Do something unexpected." }
        ]
    };
}


const narrateAdventurePrompt = ai.definePrompt({
  name: 'narrateAdventurePrompt',
  input: { schema: NarrateAdventureInputSchema },
  output: { schema: NarrateAdventureOutputSchema },
  prompt: `You are a creative Game Master AI for the text adventure "Endless Tales". Your task is to narrate the next segment of the story.

**Character Details:**
*   Name: {{{character.name}}}
*   Class/Role: {{{character.class}}} {{#if character.skillTreeSummary}}(Skill Stage: {{{character.skillTreeStage}}}/4 - {{character.skillTreeSummary.className}}){{/if}}
*   Description: {{#if character.aiGeneratedDescription}}{{character.aiGeneratedDescription}}{{else}}{{character.description}}{{/if}}
*   Traits: {{#if character.traits}}{{#each character.traits}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}}
*   Knowledge: {{#if character.knowledge}}{{#each character.knowledge}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}}
*   Background: {{{character.background}}}
*   Stats: STR {{{character.stats.strength}}}, STA {{{character.stats.stamina}}}, WIS {{{character.stats.wisdom}}}
*   Resources: Health {{character.currentHealth}}/{{character.maxHealth}}, Action Stamina {{character.currentStamina}}/{{character.maxStamina}}, Mana {{character.currentMana}}/{{character.maxMana}}
*   Level: {{character.level}} (XP: {{character.xp}}/{{character.xpToNextLevel}})
*   Learned Skills: {{#if character.learnedSkills}}{{#each character.learnedSkills}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}}
*   Reputation: {{{character.reputationString}}}
*   NPC Relationships: {{{character.npcRelationshipsString}}}

**Game Settings & Context:**
*   Turn: {{{turnCount}}}
*   Difficulty: {{{adventureSettings.difficulty}}}
*   Permadeath: {{{adventureSettings.permanentDeath}}}
*   Adventure Type: {{{adventureSettings.adventureType}}}
{{#if isCustomAdventure}}
*   World: {{{adventureSettings.worldType}}}
*   Main Quest: {{{adventureSettings.mainQuestline}}}
*   Genre/Theme: {{{adventureSettings.genreTheme}}}
*   Magic System: {{{adventureSettings.magicSystem}}}
*   Tech Level: {{{adventureSettings.techLevel}}}
*   Dominant Tone: {{{adventureSettings.dominantTone}}}
*   Starting Situation: {{{adventureSettings.startingSituation}}}
*   Combat Frequency: {{{adventureSettings.combatFrequency}}}
*   Puzzle Frequency: {{{adventureSettings.puzzleFrequency}}}
*   Social Focus: {{{adventureSettings.socialFocus}}}
{{else if isImmersedAdventure}}
*   Universe: {{{adventureSettings.universeName}}}
*   Character Role/Concept: {{{adventureSettings.playerCharacterConcept}}} (Origin: {{{adventureSettings.characterOriginType}}})
*   **INSTRUCTION (Immersed):** The narrative MUST strongly adhere to the lore, characters, and tone of the specified 'Universe'.
    *   If character origin is 'existing' AND this is Turn 1: **Attempt to start the narration at a recognizable and pivotal early point in this character's known story or a logical starting point for them within their established narrative.**
    *   Avoid class-based skill trees, XP, and standard leveling for Immersed mode; character development, new abilities, or status changes should be purely narrative-driven and logical within the universe.
{{else if isRandomizedAdventure}}
*   **INSTRUCTION (Randomized):** Focus the narration on establishing a unique setting, initial challenge, or short-term goal derived directly from the character's class, background, traits, or knowledge. Use these details to make the randomized world feel tailored to the player character, especially in early turns.
{{/if}}
*   Previous Narration (if any): {{{previousNarration}}}
*   Current Game State: {{{gameState}}}

**Player's Chosen Action:**
{{{playerChoice}}} (This may include dice roll results like "(Difficulty: Normal, Dice Roll Result: 15/20)")

**Your Task & Output Requirements:**

1.  **Narrative Continuation:** Craft an engaging narrative that seamlessly continues the story, logically following the 'playerChoice' within the 'gameState'. Consider all character details, game settings, and the specific instructions for the adventure type.
2.  **Logical Progression, Resource Costs & Restrictions:**
    *   **Evaluate Feasibility:** Assess if the action is logically possible. *Actions tied to higher skill stages (if applicable, i.e., not Immersed mode) should only be possible if the character has reached that stage.* Harder difficulties might make certain actions less feasible initially.
    *   **Check Learned Skills & Resources:** Verify if a used skill is learned and if enough resources (action stamina/mana) are available. Narrate failure reasons (not learned, insufficient resources). Calculate costs and output \`staminaChange\`, \`manaChange\` **only if they changed**.
    *   **Block Impossible Actions:** Prevent universe-breaking actions (e.g., "destroy the universe", "teleport to another dimension") unless EXTREME justification exists in gameState AND skill stage is high (if applicable). Simple reality-bending ("become king", "control time") is also typically Impossible without justification.
    *   **Narrate Failure Reason:** If blocked/failed, explain why (lack of skill, resources, item, stage, reputation, **NPC relationships**, difficulty, etc.).
    *   **Skill-based Progression (Not for Immersed):** Very powerful actions require high milestones AND skill stages.
3.  **Incorporate Dice Rolls:** Interpret dice roll results (e.g., "(Difficulty: Hard, Dice Roll Result: 75/100)") contextually. High rolls succeed, low rolls fail, adjusted by **game difficulty**. Narrate the degree of success/failure. Success might grant more XP or better reputation/relationship changes. Failure might have negative consequences (including health loss), potentially more severe on higher difficulties.
4.  **Consequences, Resources, XP, Reputation, Relationships & Character Progression:**
    *   **Health Changes:** If the character takes damage or is healed, include \`healthChange\`. **Only include if health changed.**
    *   **Resource Changes (Action Stamina/Mana):** If current action stamina or mana changed, include \`staminaChange\` or \`manaChange\`. **Do not include if unchanged.**
    *   **XP Awards (Not for Immersed):** If the action was significant, award XP via \`xpGained\`. **Only include if XP was gained.**
    *   **Reputation Changes:** If the action affects a faction's view, include \`reputationChange\`. **Only include if reputation changed.**
    *   **NPC Relationship Changes:** If the action affects an NPC's view, include \`npcRelationshipChange\`. **Only include if relationship changed.**
    *   **Character Progression (Optional, narrative for Immersed):** If events lead to development:
        *   Include \`updatedStats\`, \`updatedTraits\`, \`updatedKnowledge\`. **Only include if they changed.**
        *   **Skill Stage Progression (Not for Immersed):** Include \`progressedToStage\` **only if milestones warrant advancement.**
        *   **Class Change Suggestion (Not for Immersed):** Include \`suggestedClassChange\` **only if actions strongly align elsewhere.**
        *   **Gaining Skills (Narrative for Immersed):** Include \`gainedSkill\` **only if appropriate.**
5.  **Character Defeat:** If the narrative results in the character's Health (currentHealth) dropping to 0 or below, or any other condition that means the character is defeated/killed, you MUST set \`isCharacterDefeated: true\`. Otherwise, omit this field or set it to false.
6.  **Update Game State String:** Modify the 'gameState' string to reflect **ALL** changes (location, inventory, NPC moods, time, quest progress, milestones, status like 'Injured'). **It MUST include the current Turn count, which is always {{{turnCount}}} + 1.**
7.  **Dynamic Events & Branching Choices:**
    *   Optionally, introduce a dynamic world event via \`dynamicEventTriggered\`.
    *   You MUST ALWAYS provide **EXACTLY 4** meaningful branching choices for the player via the \`branchingChoices\` field. These choices should reflect possible next actions, dialogues, or investigations. If the current narrative moment is very direct, ensure the choices still offer variety, perhaps including general exploration options (e.g., "Look around more closely", "Consider your options") or internal thoughts/reflections (e.g., "Focus on your main goal", "Recall what you know about this place"). Each choice MUST have a 'text' field and an optional 'consequenceHint'.
8.  **Tone:** Maintain a consistent tone suitable for the adventure type and difficulty.

**Output Format:** Respond ONLY with the JSON object matching the NarrateAdventureOutput schema.
*   \`narration\` and \`updatedGameState\` are **REQUIRED**.
*   \`branchingChoices\` is **REQUIRED** and MUST contain **exactly 4** choices.
*   All other fields are **OPTIONAL** and should **ONLY** be included if their corresponding event actually occurred.
*   Ensure the \`updatedGameState\` string contains the correct turn count.
`,
});

const narrateAdventureFlow = ai.defineFlow(
  {
    name: 'narrateAdventureFlow',
    inputSchema: NarrateAdventureInputSchema,
    outputSchema: NarrateAdventureOutputSchema,
  },
  async (input: NarrateAdventureInput): Promise<NarrateAdventureOutput> => {
    const { character, adventureSettings, turnCount, playerChoice, gameState, previousNarration } = input;
    console.log(`narrateAdventureFlow: START - Processing Turn ${turnCount} for ${character.name}. Action: "${playerChoice.substring(0,100)}..."`);

    const promptInput = {
      ...input,
      character: {
        ...character,
        reputationString: character.reputationString || "None specified",
        npcRelationshipsString: character.npcRelationshipsString || "None specified",
      },
      isCustomAdventure: adventureSettings.adventureType === "Custom",
      isRandomizedAdventure: adventureSettings.adventureType === "Randomized",
      isImmersedAdventure: adventureSettings.adventureType === "Immersed",
    };

    console.log("narrateAdventureFlow: Sending to narrateAdventurePrompt with full input:", JSON.stringify(promptInput, null, 2).substring(0, 2000) + "..."); // Increased log substring

    let output: NarrateAdventureOutput | undefined;
    const genericChoices: NarrateAdventureOutput['branchingChoices'] = [ // Ensure type safety
        { text: "Look around more closely.", consequenceHint: "May reveal new details." },
        { text: "Consider your next move carefully.", consequenceHint: "Take a moment to think." },
        { text: "Check your inventory and status.", consequenceHint: "Review your belongings and condition." },
        { text: "Rest here for a moment.", consequenceHint: "Regain composure or stamina." }
    ];

    try {
        const result = await narrateAdventurePrompt(promptInput);
        output = result.output;
        console.log("narrateAdventureFlow: Received raw output from AI:", JSON.stringify(output, null, 2).substring(0, 2000) + "...");

        // --- Robust Fallback and Validation ---
        if (!output || !output.narration || !output.narration.trim() || !output.updatedGameState || !output.updatedGameState.trim()) {
            console.error("narrateAdventureFlow: AI output is missing essential fields (narration or updatedGameState). Using fallback.");
            throw new Error("AI output missing essential fields.");
        }
        if (!Array.isArray(output.branchingChoices) || output.branchingChoices.length !== 4 || output.branchingChoices.some(c => !c.text)) {
            console.warn("narrateAdventureFlow: AI did not return 4 valid branching choices. Overwriting with generic choices.");
            output.branchingChoices = genericChoices;
        }

    } catch (e: any) {
        console.error("narrateAdventureFlow: ERROR calling narrateAdventurePrompt or validating output:", e.message, e.stack);
        const fallbackNarration = `The AI narrator is currently lost in thought regarding your attempt to "${playerChoice.substring(0,100)}...". The path ahead is momentarily obscured. (AI Error: ${e.message || 'Unknown AI error'}) Perhaps try a different approach or a general action like "look around"?`;
        const fallbackGameState = `${gameState} (AI Narrator Error at Turn: ${turnCount + 1})`;
        output = {
            narration: fallbackNarration,
            updatedGameState: fallbackGameState,
            branchingChoices: genericChoices,
        };
    }

    // Ensure updatedGameState always includes the correct turn count if AI forgets
    if (!output.updatedGameState.includes(`Turn: ${turnCount + 1}`)) {
        console.warn("narrateAdventureFlow: AI output for updatedGameState did not include the correct turn count. Appending it.");
        output.updatedGameState = `${output.updatedGameState.replace(/Turn: \d+/g, '').trim()}\nTurn: ${turnCount + 1}`;
    }

    console.log(`narrateAdventureFlow: END - Successfully processed Turn ${turnCount} for ${character.name}. Final output:`, JSON.stringify(output, null, 2).substring(0, 1000) + "...");
    return output;
  }
);
