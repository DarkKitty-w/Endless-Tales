'use server';
/**
 * @fileOverview An AI agent that determines the outcome of a crafting attempt in a text adventure game.
 *
 * - attemptCrafting - A function that assesses the crafting attempt.
 * - AttemptCraftingInput - The input type for the attemptCrafting function.
 * - AttemptCraftingOutput - The return type for the attemptCrafting function.
 */

import { ai } from '@/ai/ai-instance';
import { z } from 'genkit';
import type { InventoryItem, ItemQuality } from '@/types/game-types'; // Import types

// Define possible crafting outcomes/quality levels if needed directly in output
const ItemQualitySchema = z.enum(["Poor", "Common", "Uncommon", "Rare", "Epic", "Legendary"]).optional();

// Define Zod schema for the crafted item within the output
const CraftedItemSchema = z.object({
    name: z.string().describe("The name of the successfully crafted item."),
    description: z.string().describe("A description generated by the AI for the crafted item."),
    quality: ItemQualitySchema.describe("The quality of the crafted item."),
    weight: z.number().optional().describe("Optional weight of the item."),
    durability: z.number().min(0).max(100).optional().describe("Optional durability (0-100%)."),
    magicalEffect: z.string().optional().describe("Optional magical effect description."),
}).nullable(); // Allow null if crafting fails


// --- Zod Schemas (Internal - Not Exported) ---
const AttemptCraftingInputSchema = z.object({
  characterKnowledge: z.array(z.string()).describe("List of character's knowledge areas (e.g., Herbalism, Smithing, Alchemy)."),
  characterSkills: z.array(z.string()).describe("List of character's learned skills relevant to crafting (e.g., Basic Crafting, Forge Mastery)."),
  inventoryItems: z.array(z.string()).describe("List of all item names currently in the character's inventory."), // Changed to array of strings
  desiredItem: z.string().describe("The item the player is trying to craft."),
  usedIngredients: z.array(z.string()).describe("List of specific item names from the inventory the player intends to use."),
});

const AttemptCraftingOutputSchema = z.object({
  success: z.boolean().describe("Whether the crafting attempt was successful."),
  message: z.string().describe("A message describing the outcome (e.g., 'Successfully crafted a Crude Dagger!', 'Failed, the materials crumbled.', 'Impossible combination.')."),
  craftedItem: CraftedItemSchema.describe("The crafted item details if successful, otherwise null."),
  consumedItems: z.array(z.string()).describe("List of item names from 'usedIngredients' that were consumed in the attempt (even if failed)."),
});

// --- Exported Types (Derived from internal schemas) ---
export type AttemptCraftingInput = z.infer<typeof AttemptCraftingInputSchema>;
export type AttemptCraftingOutput = z.infer<typeof AttemptCraftingOutputSchema>;

// --- Exported Async Function ---
export async function attemptCrafting(input: AttemptCraftingInput): Promise<AttemptCraftingOutput> {
  return attemptCraftingFlow(input);
}

// --- Internal Prompt and Flow Definitions ---
const attemptCraftingPrompt = ai.definePrompt({
  name: 'attemptCraftingPrompt',
  input: { schema: AttemptCraftingInputSchema },
  output: { schema: AttemptCraftingOutputSchema },
  // Updated prompt to explicitly handle empty arrays
  prompt: `You are a Master Crafter AI for the text adventure "Endless Tales". Evaluate a player's crafting attempt based on their knowledge, skills, available inventory, desired item, and the ingredients they chose to use.

**Character Capabilities:**
*   Knowledge:
{{#if characterKnowledge}}{{#each characterKnowledge}}    - {{{this}}}\n{{/each}}{{else}}    - None\n{{/if}}
*   Skills:
{{#if characterSkills}}{{#each characterSkills}}    - {{{this}}}\n{{/each}}{{else}}    - None\n{{/if}}

**Full Inventory:**
{{#if inventoryItems}}{{#each inventoryItems}}    - {{{this}}}\n{{/each}}{{else}}    - Empty\n{{/if}}

**Crafting Attempt:**
*   Goal: {{{desiredItem}}}
*   Ingredients Used:
{{#if usedIngredients}}{{#each usedIngredients}}    - {{{this}}}\n{{/each}}{{else}}    - None specified\n{{/if}}

**Evaluation Task:**
Determine if the crafting attempt is possible and likely to succeed. Consider:
1.  **Plausibility:** Is crafting {{{desiredItem}}} feasible given a fantasy/medieval setting? (e.g., crafting a 'Laser Gun' is likely impossible).
2.  **Knowledge/Skills:** Does the character have relevant knowledge (e.g., Smithing for a sword, Herbalism for a potion)? Do they have crafting skills? Lack of relevant knowledge/skills makes success much less likely or impossible for complex items.
3.  **Ingredients:**
    *   Are the specified 'usedIngredients' actually in the 'Full Inventory' list?
    *   Are the ingredients logical for crafting the 'desiredItem'? (e.g., using 'Iron Ore' and 'Wood' for a sword is plausible, using 'Flowers' is not).
    *   Are *enough* suitable ingredients used?
4.  **Outcome Determination:**
    *   **Impossible:** If the goal is nonsensical or ingredients are completely wrong/missing. Set success=false, provide a clear message, consume no items (empty consumedItems).
    *   **Failure (Materials Consumed):** If plausible but failed due to lack of skill, poor combination, or bad luck. Set success=false, list the *actually used* ingredients in consumedItems. Provide a descriptive failure message.
    *   **Success:** If plausible, ingredients are suitable, and character knowledge/skills support it. Set success=true.
        *   Generate a fitting 'name', 'description', and 'quality' (Poor, Common, Uncommon, Rare, Epic, Legendary - based on ingredients/skills/luck) for the 'craftedItem'. Add optional weight/durability/effect if appropriate.
        *   List the *actually used* ingredients in consumedItems.
        *   Provide a success message.

**Output Format:** Respond ONLY with the JSON object matching the AttemptCraftingOutput schema. Ensure 'success', 'message', 'craftedItem' (null if failed), and 'consumedItems' fields are populated correctly based on your evaluation. Ensure consumedItems ONLY lists items from the 'usedIngredients' input that were realistically used in the attempt.
`,
});


const attemptCraftingFlow = ai.defineFlow<
  typeof AttemptCraftingInputSchema,
  typeof AttemptCraftingOutputSchema
>(
  {
    name: 'attemptCraftingFlow',
    inputSchema: AttemptCraftingInputSchema,
    outputSchema: AttemptCraftingOutputSchema,
  },
  async (input) => {
     // Detailed Input Logging
     console.log("Attempting crafting with validated input:", JSON.stringify(input, null, 2));
     console.log("Character Knowledge:", input.characterKnowledge);
     console.log("Character Skills:", input.characterSkills);
     console.log("Inventory Items:", input.inventoryItems);
     console.log("Desired Item:", input.desiredItem);
     console.log("Used Ingredients:", input.usedIngredients);

     let output: AttemptCraftingOutput | undefined;
     let errorOccurred = false;
     let lastError: any = null;
     let attempt = 0;
     const maxAttempts = 3; // Retry mechanism

     while (attempt < maxAttempts && !output) {
         attempt++;
         console.log(`Crafting AI call attempt ${attempt}...`);
         try {
             const result = await attemptCraftingPrompt(input); // Consider adding { temperature: 0.7 } or other config if needed
             output = result.output;

             // ---- Start Detailed Validation ----
             if (!output) {
                 throw new Error(`AI returned undefined output (attempt ${attempt}).`);
             }
             if (typeof output.success !== 'boolean') {
                  throw new Error(`AI returned invalid 'success' field (not boolean, attempt ${attempt}). Got: ${typeof output.success}`);
             }
             if (typeof output.message !== 'string' || !output.message.trim()) {
                 throw new Error(`AI returned invalid or empty 'message' field (attempt ${attempt}).`);
             }
             if (!Array.isArray(output.consumedItems) || !output.consumedItems.every(item => typeof item === 'string')) {
                 throw new Error(`AI returned invalid 'consumedItems' field (not an array of strings, attempt ${attempt}).`);
             }
             if (output.success) {
                 // If successful, craftedItem must be a valid object
                 if (!output.craftedItem) {
                     throw new Error(`AI reported success but 'craftedItem' is null or undefined (attempt ${attempt}).`);
                 }
                 if (typeof output.craftedItem !== 'object') {
                      throw new Error(`AI reported success but 'craftedItem' is not an object (attempt ${attempt}). Got: ${typeof output.craftedItem}`);
                 }
                 if (typeof output.craftedItem.name !== 'string' || !output.craftedItem.name.trim()) {
                     throw new Error(`AI returned invalid craftedItem (missing or empty name, attempt ${attempt}).`);
                 }
                 if (typeof output.craftedItem.description !== 'string' || !output.craftedItem.description.trim()) {
                    throw new Error(`AI returned invalid craftedItem (missing or empty description, attempt ${attempt}).`);
                 }
                 // Optional fields validation (if present, must be correct type)
                  if (output.craftedItem.quality !== undefined && output.craftedItem.quality !== null && typeof output.craftedItem.quality !== 'string') {
                     console.warn(`AI returned potentially invalid craftedItem quality type (attempt ${attempt}).`);
                     // Attempt to parse or discard if not matching enum
                     const qualityParse = ItemQualitySchema.safeParse(output.craftedItem.quality);
                     output.craftedItem.quality = qualityParse.success ? qualityParse.data : undefined;
                  }
                  if (output.craftedItem.weight !== undefined && output.craftedItem.weight !== null && typeof output.craftedItem.weight !== 'number') {
                       console.warn(`AI returned potentially invalid craftedItem weight type (attempt ${attempt}).`);
                       output.craftedItem.weight = undefined; // Discard invalid type
                  }
                   if (output.craftedItem.durability !== undefined && output.craftedItem.durability !== null && typeof output.craftedItem.durability !== 'number') {
                       console.warn(`AI returned potentially invalid craftedItem durability type (attempt ${attempt}).`);
                        output.craftedItem.durability = undefined; // Discard invalid type
                   }
                    if (output.craftedItem.magicalEffect !== undefined && output.craftedItem.magicalEffect !== null && typeof output.craftedItem.magicalEffect !== 'string') {
                       console.warn(`AI returned potentially invalid craftedItem magicalEffect type (attempt ${attempt}).`);
                        output.craftedItem.magicalEffect = undefined; // Discard invalid type
                   }
             } else {
                 // If failed, craftedItem MUST be null
                 if (output.craftedItem !== null) {
                     console.warn(`AI reported failure but 'craftedItem' was not null. Setting to null (attempt ${attempt}).`);
                     output.craftedItem = null;
                 }
             }
             // ---- End Detailed Validation ----

             // If validation passes, break the loop
             break;

         } catch (err: any) {
             console.error(`Crafting AI attempt ${attempt} error:`, err);
             lastError = err; // Store the last error encountered
             output = undefined; // Reset output on error to force retry

             if (attempt >= maxAttempts) {
                  // Final failure after retries - throw a more specific error including details if possible
                 const errorMessage = `Failed to get valid crafting result after ${maxAttempts} attempts. Last error: ${lastError?.message || 'Unknown failure during flow execution.'}`;
                 console.error(errorMessage);
                 throw new Error(errorMessage);
             }
              // Wait with exponential backoff before retrying
             const waitTime = 500 * Math.pow(2, attempt -1); // 500ms, 1000ms, 2000ms...
             console.log(`Waiting ${waitTime}ms before next crafting attempt...`);
             await new Promise(resolve => setTimeout(resolve, waitTime));
         }
     }

     // If after all retries, output is still undefined, something went fundamentally wrong
     if (!output) {
         const finalErrorMessage = `Crafting failed: Could not obtain a valid response from AI after all retries. Last error: ${lastError?.message || 'Unknown failure during flow execution.'}`;
         console.error(finalErrorMessage);
         throw new Error(finalErrorMessage);
     }

     console.log("Received valid crafting result:", JSON.stringify(output, null, 2));
     return output;
  }
);
