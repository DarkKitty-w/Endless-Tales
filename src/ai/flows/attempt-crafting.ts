'use server';
/**
 * @fileOverview An AI agent that determines the outcome of a crafting attempt in a text adventure game.
 *
 * - attemptCrafting - A function that assesses the crafting attempt.
 * - AttemptCraftingInput - The input type for the attemptCrafting function.
 * - AttemptCraftingOutput - The return type for the attemptCrafting function.
 */

import { ai } from '@/ai/ai-instance';
import { z } from 'genkit';
import type { InventoryItem, ItemQuality } from '@/context/GameContext'; // Import types

// Define possible crafting outcomes/quality levels if needed directly in output
const ItemQualitySchema = z.enum(["Poor", "Common", "Uncommon", "Rare", "Epic", "Legendary"]).optional();

// Define Zod schema for the crafted item within the output
const CraftedItemSchema = z.object({
    name: z.string().describe("The name of the successfully crafted item."),
    description: z.string().describe("A description generated by the AI for the crafted item."),
    quality: ItemQualitySchema.describe("The quality of the crafted item."),
    weight: z.number().optional().describe("Optional weight of the item."),
    durability: z.number().min(0).max(100).optional().describe("Optional durability (0-100%)."),
    magicalEffect: z.string().optional().describe("Optional magical effect description."),
}).nullable(); // Allow null if crafting fails


// --- Zod Schemas (Internal - Not Exported) ---
const AttemptCraftingInputSchema = z.object({
  characterKnowledge: z.array(z.string()).describe("List of character's knowledge areas (e.g., Herbalism, Smithing, Alchemy)."),
  characterSkills: z.array(z.string()).describe("List of character's learned skills relevant to crafting (e.g., Basic Crafting, Forge Mastery)."),
  inventoryItems: z.array(z.string()).describe("List of all item names currently in the character's inventory."), // Changed to array of strings
  desiredItem: z.string().describe("The item the player is trying to craft."),
  usedIngredients: z.array(z.string()).describe("List of specific item names from the inventory the player intends to use."),
});

const AttemptCraftingOutputSchema = z.object({
  success: z.boolean().describe("Whether the crafting attempt was successful."),
  message: z.string().describe("A message describing the outcome (e.g., 'Successfully crafted a Crude Dagger!', 'Failed, the materials crumbled.', 'Impossible combination.')."),
  craftedItem: CraftedItemSchema.describe("The crafted item details if successful, otherwise null."),
  consumedItems: z.array(z.string()).describe("List of item names from 'usedIngredients' that were consumed in the attempt (even if failed)."),
});

// --- Exported Types (Derived from internal schemas) ---
export type AttemptCraftingInput = z.infer<typeof AttemptCraftingInputSchema>;
export type AttemptCraftingOutput = z.infer<typeof AttemptCraftingOutputSchema>;

// --- Exported Async Function ---
export async function attemptCrafting(input: AttemptCraftingInput): Promise<AttemptCraftingOutput> {
  return attemptCraftingFlow(input);
}

// --- Internal Prompt and Flow Definitions ---
const attemptCraftingPrompt = ai.definePrompt({
  name: 'attemptCraftingPrompt',
  input: { schema: AttemptCraftingInputSchema },
  output: { schema: AttemptCraftingOutputSchema },
  prompt: `You are a Master Crafter AI for the text adventure "Endless Tales". Evaluate a player's crafting attempt based on their knowledge, skills, available inventory, desired item, and the ingredients they chose to use.

**Character Capabilities:**
*   Knowledge: {{#if characterKnowledge}}{{#each characterKnowledge}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}}
*   Skills: {{#if characterSkills}}{{#each characterSkills}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}}

**Full Inventory:**
{{#if inventoryItems}}{{#each inventoryItems}}- {{{this}}}\n{{/each}}{{else}}Empty{{/if}}

**Crafting Attempt:**
*   Goal: {{{desiredItem}}}
*   Ingredients Used: {{#if usedIngredients}}{{#each usedIngredients}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None Specified{{/if}}

**Evaluation Task:**
Determine if the crafting attempt is possible and likely to succeed. Consider:
1.  **Plausibility:** Is crafting {{{desiredItem}}} feasible given a fantasy/medieval setting? (e.g., crafting a 'Laser Gun' is likely impossible).
2.  **Knowledge/Skills:** Does the character have relevant knowledge (e.g., Smithing for a sword, Herbalism for a potion)? Do they have crafting skills? Lack of relevant knowledge/skills makes success much less likely or impossible for complex items.
3.  **Ingredients:**
    *   Are the specified 'usedIngredients' actually in the 'Full Inventory' list?
    *   Are the ingredients logical for crafting the 'desiredItem'? (e.g., using 'Iron Ore' and 'Wood' for a sword is plausible, using 'Flowers' is not).
    *   Are *enough* suitable ingredients used?
4.  **Outcome Determination:**
    *   **Impossible:** If the goal is nonsensical or ingredients are completely wrong/missing. Set success=false, provide a clear message, consume no items (empty consumedItems).
    *   **Failure (Materials Consumed):** If plausible but failed due to lack of skill, poor combination, or bad luck. Set success=false, list the *actually used* ingredients in consumedItems. Provide a descriptive failure message.
    *   **Success:** If plausible, ingredients are suitable, and character knowledge/skills support it. Set success=true.
        *   Generate a fitting 'name', 'description', and 'quality' (Poor, Common, Uncommon, Rare, Epic, Legendary - based on ingredients/skills/luck) for the 'craftedItem'. Add optional weight/durability/effect if appropriate.
        *   List the *actually used* ingredients in consumedItems.
        *   Provide a success message.

**Output Format:** Respond ONLY with the JSON object matching the AttemptCraftingOutput schema. Ensure 'success', 'message', 'craftedItem' (null if failed), and 'consumedItems' fields are populated correctly based on your evaluation. Ensure consumedItems ONLY lists items from the 'usedIngredients' input that were realistically used in the attempt.
`,
});


const attemptCraftingFlow = ai.defineFlow<
  typeof AttemptCraftingInputSchema,
  typeof AttemptCraftingOutputSchema
>(
  {
    name: 'attemptCraftingFlow',
    inputSchema: AttemptCraftingInputSchema,
    outputSchema: AttemptCraftingOutputSchema,
  },
  async (input) => {
     console.log("Sending to attemptCraftingPrompt:", JSON.stringify(input, null, 2));
     let output: AttemptCraftingOutput | undefined;
     let errorOccurred = false;
     let attempt = 0;
     const maxAttempts = 3; // Retry mechanism

     while (attempt < maxAttempts && !output) {
         attempt++;
         try {
             const result = await attemptCraftingPrompt(input);
             output = result.output;

             // Validation
             if (!output || typeof output.success !== 'boolean' || !output.message || !Array.isArray(output.consumedItems)) {
                 throw new Error(`AI returned invalid structure (attempt ${attempt}). Missing fields.`);
             }
             if (output.success && !output.craftedItem) {
                  throw new Error(`AI reported success but missing craftedItem details (attempt ${attempt}).`);
             }
              if (output.success && output.craftedItem && (!output.craftedItem.name || !output.craftedItem.description)) {
                 throw new Error(`AI returned invalid craftedItem (missing name or description) (attempt ${attempt}).`);
             }
             if (!output.success && output.craftedItem !== null) {
                 // Allow null for failed crafts, but not an object
                  console.warn(`AI reported failure but provided a craftedItem object. Setting craftedItem to null (attempt ${attempt}).`);
                  output.craftedItem = null;
             }
              // Ensure consumed items are strings
              if (!output.consumedItems.every(item => typeof item === 'string')) {
                 throw new Error(`AI returned invalid consumedItems array (non-string elements found) (attempt ${attempt}).`);
              }


         } catch (err: any) {
             console.error(`Crafting AI attempt ${attempt} error:`, err);
             errorOccurred = true;
             if (attempt >= maxAttempts) {
                 // Final failure after retries
                 throw new Error(`Failed to get valid crafting result after ${maxAttempts} attempts. Last error: ${err.message}`);
             }
             await new Promise(resolve => setTimeout(resolve, 500 * attempt)); // Wait before retrying
         }
     }

     if (!output) {
         // Should not happen if loop completes and throws, but as a fallback
         throw new Error(`Crafting generation failed for goal "${input.desiredItem}".`);
     }


     console.log("Received valid crafting result:", JSON.stringify(output, null, 2));
     return output;
  }
);

    
    